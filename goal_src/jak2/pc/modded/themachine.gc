;;-*-Lisp-*-
(in-package goal)

;; name: themachine.gc

(define machine-current-pos (new 'static 'vector :x (meters 0.0) :y (meters 0.0) :z (meters 0.0) :w 1.0))
(define hideout-machine-spawn-pos (new 'static 'vector :x (meters 1136.4810) :y (meters 8.0) :z (meters 3.2301) :w 1.0))
(define port-machine-spawn-pos (new 'static 'vector :x (meters -62.8353) :y (meters 8.9) :z (meters 1323.0412) :w 1.0))
(define sewer-machine-spawn-pos (new 'static 'vector :x (meters 1352.5213) :y (meters -42.85) :z (meters 483.4087) :w 1.0))
(define strip-machine-spawn-pos (new 'static 'vector :x (meters 2373.8669) :y (meters 69.8985) :z (meters -35.3681) :w 1.0))
(define mountain-machine-spawn-pos (new 'static 'vector :x (meters -741.1651) :y (meters 80.9000) :z (meters 13.4026) :w 1.0))
(define ruins-machine-spawn-pos (new 'static 'vector :x (meters 907.4705) :y (meters 0.1) :z (meters -400.1474) :w 1.0))
(define markb-machine-spawn-pos (new 'static 'vector :x (meters 520.5573) :y (meters 9.7) :z (meters 414.9625) :w 1.0))
(define atoll-machine-spawn-pos (new 'static 'vector :x (meters 579.5821) :y (meters 0.6) :z (meters -851.6854) :w 1.0))
(define forest-machine-spawn-pos (new 'static 'vector :x (meters -598.8101) :y (meters 30.8) :z (meters 579.3311) :w 1.0))
(define dig1-machine-spawn-pos (new 'static 'vector :x (meters 451.9943) :y (meters -58.5069) :z (meters -1810.1236) :w 1.0))
(define dig3a-machine-spawn-pos (new 'static 'vector :x (meters 337.2496) :y (meters -74.0) :z (meters -2037.3114) :w 1.0))

(define challenge-string "")
(define in-challenge? #f)

(defun-extern machine-run (none))
(defun-extern machine-exit (none))
(defun-extern recieve-reward-end (none))
(defun-extern recieve-reward-during (none))

(define machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
(define machinev-cam-final machine-current-pos)


(declare-type whack-a-metal process-drawable)
(define-extern whack-a-metal-init (function entity-actor none :behavior whack-a-metal))



  (deftype chip-whack-a-metal (process-taskable)
  ()
  )

  (define *rift-tracker* (the (pointer rift-ring-ingame) #f))
  (define *machine-tracker* (the (pointer chip-whack-a-metal) #f))


(defskelgroup skel-hip-whack-a-metal hip-whack-a-metal hip-whack-a-metal-lod0-jg hip-whack-a-metal-idle-ja
              ((hip-whack-a-metal-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 -1 1 3.8)
              :origin-joint-index 3
              )



(defstate hide (chip-whack-a-metal)
  :virtual #t
  :enter #f
  :exit #f
  :code (behavior ()
    (ja-post)
    (sleep-code)
    )
  )

;; WARN: Return type mismatch draw-control vs none.
(defmethod init-art! ((this chip-whack-a-metal))
  "@see [[initialize-skeleton]]"
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-hip-whack-a-metal" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (none)
  )

(defmethod get-art-elem ((this chip-whack-a-metal))
  "Checks various things such the current actor, task status, etc to determine the right art-group data to use
@returns the appropriate [[art-element]] for the given NPC"
  (case (-> (get-current-task-event (-> this task)) action)
    (((game-task-action play))
     (set! (-> this talk-message) (text-id press-triangle-to-play))
     )
    (else
      (set! (-> this talk-message) (text-id press-triangle-to-talk))
      )
    )
  (-> this draw art-group data 2)
  )

(defstate play-game (chip-whack-a-metal)
  :virtual #t
  :code (behavior ((arg0 game-task-event))
    (set-setting! 'borrow '((hiphog 0 lwhack special)) 0.0 0)
    (process-taskable-anim-loop
      (the-as (function process-taskable object) (lambda () (!= (level-status *level* 'lwhack) 'active)))
      )
    (let ((gp-0 (get-process *default-dead-pool* whack-a-metal #x4000)))
      (set! (-> self slave)
            (ppointer->handle (when gp-0
                                (let ((t9-3 (method-of-type process activate)))
                                  (t9-3 gp-0 self (symbol->string (-> whack-a-metal symbol)) (the-as pointer #x70004000))
                                  )
                                (run-now-in-process gp-0 whack-a-metal-init (-> self entity))
                                (-> gp-0 ppointer)
                                )
                              )
            )
      )
    (process-taskable-anim-loop (lambda ((arg0 process-taskable)) (handle->process (-> arg0 slave))))
    (remove-setting! 'borrow)
    (go-virtual idle)
    )
  )

  (defbehavior chip-whack-a-metal-init-by-other chip-whack-a-metal ((vec vector))
  (stack-size-set! (-> self main-thread) 512)
  (process-taskable-method-31 self)
  (logior! (-> self mask) (process-mask actor-pause))
  (vector-copy! (-> self root trans) vec)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (set! (-> self task) (new 'process 'game-task-control (game-task-actor whack-a-metal-hiphog)))
  (init-art! self)
  (process-taskable-method-32 self)
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (go (method-of-object self hide))
  (none)
)

(define machine-interact-rad 30000.0)
(define machine-spawn-rad 800000.0)

(define x-aspect-ratio-challenge 0)
(define y-aspect-ratio-challenge 0)


(defun machine-update ()

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MACHINE PARAMS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(when (and (= in-challenge? #t) (= challenge-mission 0))
    (set! in-challenge? #f)
)

(when ;display interact prompt
(and
(= machine-spawning? #t)
(ppointer->process *machine-tracker*)
(< (vector-vector-distance (target-pos 0) machine-current-pos) machine-interact-rad)
(= popup-shop #f)
(= avoidc-waitb #f)
(= machine-prompt? #f)
(= mode-challenge? #f)
)
(set! machine-prompt? #t)
)

(when ;dont display interact prompt
(and
(= machine-spawning? #t)
(ppointer->process *machine-tracker*)
(> (vector-vector-distance (target-pos 0) machine-current-pos) machine-interact-rad)
(= popup-shop #f)
(= machine-prompt? #t)
)
(set! machine-prompt? #f)
)

(when (and (= machine-prompt? #t)(= avoidc-waitb #f)(= machine-locked? #f)(= in-machine? #f)(= (paused?) #f)(= (pause-allowed?) #t) *target* (= in-hub? #f)) ;draw interact button
    (clear matt-str)
    (clear *pc-encoded-matt-str*)
    (format matt-str "<COLOR_RED>R3<COLOR_WHITE>:<COLOR_ORANGE> Access Challenge Machine <COLOR_PINK>(15 Tokens)~%<COLOR_ORANGE>Current Tokens: <COLOR_PINK>~d"
    (the int (-> *game-info* fuel))
    )
    (pc-encode-utf8-string matt-str *pc-encoded-matt-str*)
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf1))
      ;; reset bucket settings prior to drawing - font won't do self for us, and
      ;; draw-raw-image can sometimes mess them up. (intro sequence)
      (dma-buffer-add-gs-set-flusha buf (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)) (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1)))
      (let ((font-ctx (new 'stack 'font-context *font-default-matrix* 0 245 0.0 (font-color default) (font-flags shadow kerning large))))
        (set! (-> font-ctx scale) 0.325)
        (draw-string-adv *pc-encoded-matt-str* buf font-ctx)))
)

(when (and (= machine-prompt? #t)(= machine-locked? #t)(= in-machine? #f)(= (paused?) #f)(= (pause-allowed?) #t) *target* (= in-hub? #f)) ;draw interact button
    (clear matt-str)
    (clear *pc-encoded-matt-str*)
    (format matt-str "<COLOR_RED>LOCKED, WAITING FOR CHALLENGE COMPLETION~%<COLOR_ORANGE>Current Tokens: <COLOR_PINK>~d"
    (the int (-> *game-info* fuel))
    )
    (pc-encode-utf8-string matt-str *pc-encoded-matt-str*)
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf1))
      ;; reset bucket settings prior to drawing - font won't do self for us, and
      ;; draw-raw-image can sometimes mess them up. (intro sequence)
      (dma-buffer-add-gs-set-flusha buf (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)) (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1)))
      (let ((font-ctx (new 'stack 'font-context *font-default-matrix* 0 245 0.0 (font-color default) (font-flags shadow kerning large))))
        (set! (-> font-ctx scale) 0.325)
        (draw-string-adv *pc-encoded-matt-str* buf font-ctx)))
)

(when (and (= d-challenge-failed #t)(= mode-challenge? #t))
    (set! (-> *target* fact health) 0.0)
)

(when (and (= d-challenge-failed #t)(= (paused?) #f)(= (pause-allowed?) #t) *target* (= in-hub? #f))
    (+! d-cfi 1)
    (clear matt-str)
    (clear *pc-encoded-matt-str*)
    (format matt-str "<COLOR_RED>CHALLENGE FAILED"
    )
    (pc-encode-utf8-string matt-str *pc-encoded-matt-str*)
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf1))
      ;; reset bucket settings prior to drawing - font won't do self for us, and
      ;; draw-raw-image can sometimes mess them up. (intro sequence)
      (dma-buffer-add-gs-set-flusha buf (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)) (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1)))
      (let ((font-ctx (new 'stack 'font-context *font-default-matrix* 255 60 0.0 (font-color default) (font-flags middle shadow kerning large))))
        (set! (-> font-ctx scale) 0.325)
        (draw-string-adv *pc-encoded-matt-str* buf font-ctx)))
        (when (>= d-cfi 600)
            (set! d-cfi 0)
            (set! d-challenge-failed #f)
        )
)

(when (and (= d-challenge-won #t)(= (paused?) #f)(= (pause-allowed?) #t) *target* (= in-hub? #f))
    (+! d-cwi 1)
    (clear matt-str)
    (clear *pc-encoded-matt-str*)
    (format matt-str "<COLOR_GREEN>CHALLENGE SUCCESS!~%<COLOR_ORANGE>You won ~s"
    reward-string
    )
    (pc-encode-utf8-string matt-str *pc-encoded-matt-str*)
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf1))
      ;; reset bucket settings prior to drawing - font won't do self for us, and
      ;; draw-raw-image can sometimes mess them up. (intro sequence)
      (dma-buffer-add-gs-set-flusha buf (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)) (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1)))
      (let ((font-ctx (new 'stack 'font-context *font-default-matrix* 255 60 0.0 (font-color default) (font-flags middle shadow kerning large))))
        (set! (-> font-ctx scale) 0.325)
        (draw-string-adv *pc-encoded-matt-str* buf font-ctx)))
        (when (>= d-cwi 600)
            (set! d-cwi 0)
            (set! d-challenge-won #f)
        )
)

(when 
    (and 
        (or 
        (= mode-challenge? #t)
        (= in-challenge? #t)
        )
        (!= challenge-mission 0)
        (!= challenge-mission 2)
        (!= challenge-mission 4)
        (= in-hub? #f)
        (= run-in-progress #t)
    )
    (clear matt-str)
    (clear *pc-encoded-matt-str*)
    (format matt-str "<COLOR_WHITE>Current Challenge:~%<COLOR_ORANGE>~s"
    challenge-string
    )
    (pc-encode-utf8-string matt-str *pc-encoded-matt-str*)
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf1))
      ;; reset bucket settings prior to drawing - font won't do self for us, and
      ;; draw-raw-image can sometimes mess them up. (intro sequence)
      (dma-buffer-add-gs-set-flusha buf (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)) (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1)))
      (let ((font-ctx (new 'stack 'font-context *font-default-matrix* 1 10 0.0 (font-color default) (font-flags shadow kerning large))))
        (set! (-> font-ctx scale) 0.325)
        (draw-string-adv *pc-encoded-matt-str* buf font-ctx)))
)

(when 
    (and 
        (or 
        (= mode-challenge? #t)
        (= in-challenge? #t)
        )
        (!= challenge-mission 0)
        (!= challenge-mission 2)
        (= challenge-mission 4)
        (= in-hub? #f)
        (= run-in-progress #t)
    )
    (clear matt-str)
    (clear *pc-encoded-matt-str*)
    (format matt-str "<COLOR_WHITE>Current Challenge:~%<COLOR_ORANGE>~s <COLOR_YELLOW>~d/50"
    challenge-string
    enemies-killed?
    )
    (pc-encode-utf8-string matt-str *pc-encoded-matt-str*)
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf1))
      ;; reset bucket settings prior to drawing - font won't do self for us, and
      ;; draw-raw-image can sometimes mess them up. (intro sequence)
      (dma-buffer-add-gs-set-flusha buf (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)) (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1)))
      (let ((font-ctx (new 'stack 'font-context *font-default-matrix* 1 10 0.0 (font-color default) (font-flags shadow kerning large))))
        (set! (-> font-ctx scale) 0.325)
        (draw-string-adv *pc-encoded-matt-str* buf font-ctx)))
)

(when (and 
        (or 
        (= mode-challenge? #t)
        (= in-challenge? #t)
        )
        (!= challenge-mission 0)
        (= challenge-mission 2)
        (!= challenge-mission 4)
        (= in-hub? #f)
        (= run-in-progress #t)
    )
    (clear matt-str)
    (clear *pc-encoded-matt-str*)
    (format matt-str "<COLOR_WHITE>Current Challenge:~%<COLOR_ORANGE>~s <COLOR_YELLOW>~d/15"
    challenge-string
    (the int pc-stored-orbs)
    )
    (pc-encode-utf8-string matt-str *pc-encoded-matt-str*)
    (with-dma-buffer-add-bucket ((buf (-> (current-frame) global-buf)) (bucket-id debug-no-zbuf1))
      ;; reset bucket settings prior to drawing - font won't do self for us, and
      ;; draw-raw-image can sometimes mess them up. (intro sequence)
      (dma-buffer-add-gs-set-flusha buf (alpha-1 (new 'static 'gs-alpha :b #x1 :d #x1)) (tex1-1 (new 'static 'gs-tex1 :mmag #x1 :mmin #x1)))
      (let ((font-ctx (new 'stack 'font-context *font-default-matrix* 1 10 0.0 (font-color default) (font-flags shadow kerning large))))
        (set! (-> font-ctx scale) 0.325)
        (draw-string-adv *pc-encoded-matt-str* buf font-ctx)))
)

(when 
(and
(= challenge-mission 2)
(<= c-stored-orbs (-> *game-info* skill))
)
    (set! challenge-win? #t)
    (set! challenge-completed? #t)
    (set! d-challenge-won #t)
    (set! pc-stored-orbs 0.0)
)

(when 
(and
(= challenge-mission 4)
(>= enemies-killed? 50)
)
(set! challenge-completed? #t)
(set! challenge-win? #t)
)

(when (and (= frong-ingame? #f)(= machine-locked? #f)(>= (-> *game-info* fuel) 15.0)(= machine-prompt? #t) (cpad-pressed? 0 r3) (= avoidc-waitb #f)(= in-machine? #f)(= in-hub? #f)) ;run camera and jak position-settings
    (machine-run)
)

(when (and (= waite-machine #t)) ;wait for camera then run machine
    (+! waite-machinei 1)
    (when (= waite-machinei 7)
        (machine-exit)
        (set! waite-machine #f)
        (set! waite-machinei 0)
    )
)

(when (and (= wait-machine #t)) ;wait for camera then run machine
(+! wait-machinei 1)
(when (= wait-machinei 50)
    (-! (-> *game-info* fuel) 15.0)
    (set-setting-by-param *setting-control* 'mode-name 'cam-really-fixed 0 0)
    (set! wait-machinei 0)
    (set! wait-machine #f)
    (set! in-machine? #t)
    (set! in-dialogue? #t)
    (set! log-id (rand-vu-int-range 10 15))
    (set! log-sec 0)
    (set! machine-locked? #t)
    (let ((rnd (rand-vu-int-range 1 6)))
        (when (= rnd 1)
            (set! di-s "Welcome to the Challenge Machine.")
            (set! di-s2 "Here's whats on the agenda for") 
            (set! di-s3 "today's challenge.")
            (set! di-s4 "")
        )
        (when (= rnd 2)
            (set! di-s "Greetings from the Challenge Machine!")
            (set! di-s2 "Are you ready for a risk,") 
            (set! di-s3 "for a reward?")
            (set! di-s4 "")
        )
        (when (= rnd 3)
            (set! di-s "This is the Challenge Machine.")
            (set! di-s2 "Here's the gist of this stage's challenge") 
            (set! di-s3 "")
            (set! di-s4 "")
        )
        (when (= rnd 4)
            (set! di-s "WELCOME TO CHALLENGE-MACHINE")
            (set! di-s2 "PRESENTING (string='TODAYS-CHALLENGE')") 
            (set! di-s3 "")
            (set! di-s4 "")
        )
        (when (= rnd 5)
            (set! di-s "Challenge Machine Updated.")
            (set! di-s2 "Your next challenge is...") 
            (set! di-s3 "")
            (set! di-s4 "")
        )
        (when (= rnd 6)
            (set! di-s "The Challenge Machine")
            (set! di-s2 "Complete a random challenge") 
            (set! di-s3 "to gain a random reward.")
            (set! di-s4 "")
        )
    )
)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;LOG SECTION;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when 
(and
    (= in-dialogue? #t)
    (= log-id 10)
    (cpad-pressed? 0 x)
)
    (+! log-sec 1)
    (when (= log-sec 1)
        (set! di-s "You must proceed into the next stage")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 2)
        (set! di-s "Without taking damage, or bonks.")
        (set! di-s2 "Complete the rest of this level..") 
        (set! di-s3 "...flawlessly!")
        (set! di-s4 "")
    )
    (when (= log-sec 3)
        (set! di-s "After this level, you will get")
        (set! di-s2 "an extra reward alongside your orbs!") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 4)
        (set! di-s "...")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 5)
        (set! di-s "")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! waite-machine #t)
        (set! in-challenge? #t)
        (set! challenge-win? #t)
        (set! challenge-mission 1)
        (set! in-dialogue? #f)
        (set! camera-unlocked #t)
        (set! challenge-string "No Damage or Bonks")
        (set! in-challenge? #t)
    )
)


(when 
(and
    (= in-dialogue? #t)
    (= log-id 11)
    (cpad-pressed? 0 x)
)
    (+! log-sec 1)
    (when (= log-sec 1)
        (set! di-s "You must proceed into the next stage")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! c-stored-orbs (-> *game-info* skill))
    )
    (when (= log-sec 2)
        (set! di-s "...And collect at least 15 orbs!")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (+! c-stored-orbs 15.0)
    )
    (when (= log-sec 3)
        (set! di-s "When you collect 15 orbs from this point on,")
        (set! di-s2 "you'll immediately recieve a reward!") 
        (set! di-s3 "If you continue to the next level without")
        (set! di-s4 "15 or more, Jak fails the challenge.")
    )
    (when (= log-sec 4)
        (set! di-s "...")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 5)
        (set! di-s "")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! waite-machine #t)
        (set! in-challenge? #t)
        (set! pc-stored-orbs 0.0)
        (set! in-dialogue? #f)
        (set! challenge-mission 2)
        (set! camera-unlocked #t)
        (set! challenge-string "Collect 15 orbs:")
        (set! in-challenge? #t)
    )

)

(when 
(and
    (= in-dialogue? #t)
    (= log-id 12)
    (cpad-pressed? 0 x)
)
    (+! log-sec 1)
    (when (= log-sec 1)
        (set! di-s "You must proceed into the next stage")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 2)
        (set! di-s "Without using WEAPONS!")
        (set! di-s2 "Jak can only use Melee from this point on,") 
        (set! di-s3 "or he fails the challenge.")
        (set! di-s4 "")
    )
    (when (= log-sec 3)
        (set! di-s "After this level completion you will get")
        (set! di-s2 "an extra reward alongside your orbs!") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 4)
        (set! di-s "...")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 5)
        (set! di-s "")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! waite-machine #t)
        (set! in-challenge? #t)
        (set! challenge-win? #t)
        (set! challenge-mission 3)
        (set! in-dialogue? #f)
        (set! camera-unlocked #t)
        (set! challenge-string "No Weapons")
        (set! in-challenge? #t)
    )
)

(when 
(and
    (= in-dialogue? #t)
    (= log-id 13)
    (cpad-pressed? 0 x)
)
    (+! log-sec 1)
    (when (= log-sec 1)
        (set! di-s "You must proceed into the next stage")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 2)
        (set! di-s "Having already killed at least 50 enemies!")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 3)
        (set! di-s "When completed, you will gain an extra reward!")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 4)
        (set! di-s "...")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 5)
        (set! di-s "")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! waite-machine #t)
        (set! in-challenge? #t)
        (set! challenge-mission 4)
        (set! enemies-killed? 0)
        (set! in-dialogue? #f)
        (set! camera-unlocked #t)
        (set! challenge-string "Kill Enemies:")
        (set! in-challenge? #t)
    )
)

(when 
(and
    (= in-dialogue? #t)
    (= log-id 14)
    (cpad-pressed? 0 x)
)
    (+! log-sec 1)
    (when (= log-sec 1)
        (set! di-s "You must proceed into the next stage")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! c-stored-orbs (-> *game-info* skill))
    )
    (when (= log-sec 2)
        (set! di-s "...While the world is in the apocalypse!")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (+! c-stored-orbs 15.0)
    )
    (when (= log-sec 3)
        (set! di-s "Good luck, Player.")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 4)
        (set! di-s "!!!")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 5)
        (set! di-s "")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! waite-machine #t)
        (set! in-dialogue? #f)
        (play-sound-file sound-endofworld (the int (* (-> *setting-control* user-current sfx-volume) 100)))
        (send-event (ppointer->process *time-of-day*) 'change 'ratio 240.0) 
        (set! (-> *time-of-day-context* overide-enable) #f)
        (set! (-> *mood-control* overide-weather-flag) #t)
        (set! (-> *mood-control* overide fog) 1.0)
        (set! (-> *mood-control* overide cloud) 1.0)
        (set! dark-mode #t)
        (set! challenge-win? #t)
        (set! in-challenge? #t)
        (reset-actors 'debug)
        (set! challenge-mission 5)
        (set! camera-unlocked #t)
        (set! challenge-string "Survive.")
        (set! in-challenge? #t)
    )

)

(when 
(and
    (= in-dialogue? #t)
    (= log-id 15)
    (cpad-pressed? 0 x)
)
    (+! log-sec 1)
    (when (= log-sec 1)
        (set! di-s "You must proceed into the next stage")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! c-stored-orbs (-> *game-info* skill))
    )
    (when (= log-sec 2)
        (set! di-s "...Without collecting a single pickup!")
        (set! di-s2 "No HP, no ammo, no eco, or metalheads") 
        (set! di-s3 "")
        (set! di-s4 "")
        (+! c-stored-orbs 15.0)
    )
    (when (= log-sec 3)
        (set! di-s "Comeplete the rest of the level and")
        (set! di-s2 "recieve your reward along side your") 
        (set! di-s3 "orbs")
        (set! di-s4 "")
    )
    (when (= log-sec 4)
        (set! di-s "...")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
    )
    (when (= log-sec 5)
        (set! di-s "")
        (set! di-s2 "") 
        (set! di-s3 "")
        (set! di-s4 "")
        (set! waite-machine #t)
        (set! in-challenge? #t)
        (set! in-dialogue? #f)
        (set! challenge-mission 6)
        (set! challenge-win? #t)
        (set! camera-unlocked #t)
        (set! challenge-string "Do not collect a single pickup")
        (set! in-challenge? #t)
    )

)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SPAWN LOCATIONS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;HIDEOUT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'ctysluma)
    (let (
        (vec-spawn hideout-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "ctysluma")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CTYPORT;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'ctyport)
    (let (
        (vec-spawn port-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "ctyport")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SEWERS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'sewer)
    (let (
        (vec-spawn sewer-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "sewers")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;STRIP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'strip)
    (let (
        (vec-spawn strip-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "strip")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MOUNTAIN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'mountain)
    (let (
        (vec-spawn mountain-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "mountain")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;RUINS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'ruins)
    (let (
        (vec-spawn ruins-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "ruins")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MARKB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'ctymarkb)
    (let (
        (vec-spawn markb-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "markb")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATOLL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'atoll)
    (let (
        (vec-spawn atoll-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "atoll")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;FOREST;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'forest)
    (let (
        (vec-spawn forest-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "forest")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;DIG1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'dig1)
    (let (
        (vec-spawn dig1-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "dig1")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;DIG3A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(when (= (-> (level-get-target-inside *level*) name) 'dig3a)
    (let (
        (vec-spawn dig3a-machine-spawn-pos)
        (vec-offset (new-stack-vector0))
        (vec-offset2 (new-stack-vector0))
        (which-area "dig3a")
    )
        (when 
    (and
        (= machine-spawning? #t)
        (= machine-locked? #f)
        (not (ppointer->process *machine-tracker*))
        (< (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (process-spawn chip-whack-a-metal vec-spawn)
        (set! machine-current-pos vec-spawn)
        (set! machinev-camera (new 'static 'vector :x (meters 0) :y (meters 7) :z (meters 10)))
        (vector-copy! machinev-cam-final (vector+! vec-offset machine-current-pos machinev-camera))
        (set! *machine-tracker* (process-spawn chip-whack-a-metal vec-spawn))
        (format #t "~%[!!!] spawned process chip-whack-a-metal in ~s~%" which-area)
        (let (
            (frong-offset (new-stack-vector0))
            )
        (set! frong-position machine-current-pos)
        (set! vec-offset2 frong-position)
        (vector-copy! frong-position (vector+! frong-offset vec-offset2 frong-position2))
        (when (= (/ (mod (-> *game-info* auto-save-count) 100000000) 10000000) 2)
            (set! frong-spawning? #t)
        )
        )
    )

    (when 
    (and
        (= machine-spawning? #t)
        (ppointer->process *machine-tracker*)
        (> (vector-vector-distance (target-pos 0) vec-spawn) machine-spawn-rad)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )

    (when 
    (and
        (ppointer->process *machine-tracker*)
        (= machine-spawning? #f)
    )
        (kill-by-name "chip-whack-a-metal" *default-pool*)
        (kill-by-name "c-fodder" *default-pool*)
        (set! *machine-tracker* #f)
        (format #t "~%[!!!] killed chip-whack-a-metal in ~s~%" which-area)
    )
    )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    


    (when (and 
(= challenge-completed? #t)
(= challenge-win? #t)
)
    (when (!= challenge-mission 2)
        (recieve-reward-end)
    )
    (when (= challenge-mission 2)
        (recieve-reward-during)
    )
    (when (= challenge-mission 4)
        (recieve-reward-during)
    )
    (when (= challenge-mission 5)
        (recieve-reward-end)
        (set! (-> *time-of-day-context* overide-enable) #f)
        (set! (-> *mood-control* overide-weather-flag) #f)
    )
    (set! challenge-win? #f)
    (set! challenge-completed? #f)
    (set! challenge-mission 0)
    (set! d-challenge-won #t)
)
(none)
)

(defun recieve-reward-end ()
    (let ((rnd (rand-vu-int-range 1 3))
        (randominteger (rand-vu-int-range 15 40))
        )

        (when (= rnd 1)
            (let 
            (
                (tier-select (rand-vu-int-range 1 2))
                )
                (when 
                (and 
                (rand-vu-percent? (/ luck 2))
                (>= (-> *game-info* total-trys) 7)
                )
                (set! tier-select 3)
                )
                (when 
                (and 
                (rand-vu-percent? (/ luck 4))
                (>= (-> *game-info* total-trys) 9)
                )
                (set! tier-select 4)
                )
                (when (= tier-select 1)
                (set! board-tier 1)
                )
                (when (= tier-select 2)
                (set! board-tier 2)
                )
                (when (= tier-select 3)
                (set! board-tier 3)
                )
                (when (= tier-select 4)
                (set! board-tier 4)
                )
                (set! roll-randomitem #t)
            )
            (set! reward-string "a random item!")
        )
        (when (= rnd 2)
            (+! temp-skullgemamount (the float randominteger))
            (set! reward-string "some gems for your effort!")
        )
        (when (= rnd 3)
            (+! temp-orbs (the float randominteger))
            (set! reward-string "some orbs for your effort!")
        )
        (set! machine-spawning? #f)
    )
    (none)
)

(defun recieve-reward-during ()
    (let ((rnd (rand-vu-int-range 1 3))
        (randominteger (rand-vu-int-range 15 40))
        )

        (when (= rnd 1)
            (set! roll-randomitem #t)
            (set! reward-string "a random item!")
        )
        (when (= rnd 2)
            (+! (-> *game-info* gem) (the float randominteger))
            (set! reward-string "some gems for your effort!")
        )
        (when (= rnd 3)
            (+! (-> *game-info* skill) (the float randominteger))
            (set! reward-string "some orbs for your effort!")
        )
        (set! machine-spawning? #f)
    )
(none)
)

(defun challenge-mission-fail ()
    (set! challenge-win? #f)
    (set! challenge-mission 0)
    (set! challenge-completed? #f)
    (set! machine-spawning? #f)
    (set! d-challenge-failed #t)
    (set! machine-prompt? #f)
     (play-sound-file "data/goal_src/jak2/pc/snd/challenge-failed.wav" (the int (* (-> *setting-control* user-current sfx-volume) 100)))
    (none)
)

(defun machine-run ()
    (process-grab? *target* #f)
    (set-setting-by-param *setting-control* 'mode-name 'cam-really-fixed 0 0)
    (send-event *camera* 'teleport-to-vector-start-string machinev-cam-final)
    (set! wait-machine #t)
    (set! machine-prompt? #f)
    (none)
)

(defun machine-exit ()
    (remove-setting-by-arg0 *setting-control* 'mode-name)
    (process-release? *target*)
    (set! log-id 0)
    (set! log-sec 0)
    (set! in-dialogue? #f)
    (set! in-machine? #f)
    (none)
)