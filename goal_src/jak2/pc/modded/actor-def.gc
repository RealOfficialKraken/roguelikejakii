(in-package goal)

;actor-def.gc

(deftype c-kid-npc (process-taskable)
  ()
  )


(defmethod init-art! ((this c-kid-npc))
  "@see [[initialize-skeleton]]"
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-kid-highres" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this draw light-index) (the-as uint 30))
  0
  (none)
  )

(defmethod get-art-elem ((this c-kid-npc))
  "Checks various things such the current actor, task status, etc to determine the right art-group data to use
@returns the appropriate [[art-element]] for the given NPC"
  (case (-> this task actor)
    (((game-task-actor kid-alley))
     (-> this draw art-group data 5)
     )
    (((game-task-actor kid-tomb) (game-task-actor kid-vinroom))
     (-> this draw art-group data 4)
     )
    (((game-task-actor kid-hideout))
     (-> this draw art-group data 6)
     )
    (else
      (-> this draw art-group data 3)
      )
    )
  )

  (defbehavior c-kid-npc-init-by-other c-kid-npc ((vec vector)) ;spawn kid
  (stack-size-set! (-> self main-thread) 512)
  (process-taskable-method-31 self)
  (logior! (-> self mask) (process-mask actor-pause))
  (vector-copy! (-> self root trans) vec)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (set! (-> self task) (new 'process 'game-task-control (game-task-actor kid-vinroom)))
  (init-art! self)
  (process-taskable-method-32 self)
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (go (method-of-object self hide))
  (none)
  (none)
  )

(deftype c-crocadog-npc (process-taskable)
  ()
  )


(defmethod get-art-elem ((this c-crocadog-npc))
  "Checks various things such the current actor, task status, etc to determine the right art-group data to use
@returns the appropriate [[art-element]] for the given NPC"
  (case (-> this task actor)
    (((game-task-actor crocadog-vinroom))
     (-> this draw art-group data 5)
     )
    (((game-task-actor crocadog-alley))
     (-> this draw art-group data 4)
     )
    (else
      (-> this draw art-group data 4)
      )
    )
  )

(defmethod init-art! ((this c-crocadog-npc))
  "@see [[initialize-skeleton]]"
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-crocadog-highres" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this draw light-index) (the-as uint 30))
  0
  (none)
  )

(defenum rapid-gunner-flags
  :bitfield #t
  (ragflags-0)
  (ragflags-1)
  (ragflags-2)
  (ragflags-3)
  (ragflags-4)
  (ragflags-5)
  )

(deftype c-rapid-gunner (nav-enemy)
  ((los               los-control  :inline)
   (joint             joint-mod)
   (joint-blend       float)
   (joint-enable      symbol)
   (shot-timer        uint64)
   (predict-timer     uint64)
   (target-prev-pos   vector       :inline)
   (target-next-pos   vector       :inline)
   (focus-dir         vector       :inline)
   (y-diff            float)
   (shots-fired       uint32)
   (spin-up-angle     float)
   (spin-up-timer     time-frame)
   (shoot-anim-index  int32)
   (status-flags      rapid-gunner-flags)
   (start-pos         vector       :inline)
   (dest-pos          vector       :inline)
   (hop-dir           vector       :inline)
   (roam-radius       float)
   )
  (:state-methods
    attack
    spin-attack
    hop
    hop-turn
    cool-down
    reload
    )
  (:methods
    (rapid-gunner-method-184 (_type_ float) symbol)
    (rapid-gunner-method-185 (_type_ vector float) none)
    (rapid-gunner-method-186 (_type_ int float int int) none)
    )
  )


(defskelgroup skel-rapid-gunner rapid-gunner rapid-gunner-lod0-jg rapid-gunner-idle-ja
              ((rapid-gunner-lod0-mg (meters 20)) (rapid-gunner-lod1-mg (meters 40)) (rapid-gunner-lod2-mg (meters 999999)))
              :bounds (static-spherem 0 1.5 0 7)
              :shadow rapid-gunner-shadow-mg
              )

  (defbehavior c-rapid-gunner-init-by-other c-rapid-gunner ((vec vector)) ;spawn crocadog
  (process-spawn manipy
                            :init
                            manipy-init
                            vec
                            #f
                            (art-group-get-by-name *level* "skel-rapid-gunner" (the (pointer uint32) #f))
                            #f
                            0)
  (none)
  )





  (deftype metalkor (process-focusable)
  ((trackable                        symbol)
   (flitters                         handle            10)
   (flitter-gem-tracker              handle)
   (wasps                            handle            3)
   (wasp-gem-tracker                 handle)
   (last-flitter-launched            int8)
   (last-wasp-launched               int8)
   (live-flitters                    int8)
   (live-wasps                       int8)
   (shoot-timer                      time-frame)
   (target-angle                     float)
   (wave-timer                       time-frame)
   (in-wave                          symbol)
   (flitter-timer                    time-frame)
   (wasp-timer                       time-frame)
   (launching-flitters               symbol)
   (launching-wasps                  symbol)
   (egg-timer                        time-frame)
   (last-close-attack                int8)
   (last-standing-attack             int8)
   (stage                            int8)
   (next-stage-timer                 time-frame)
   (initial-y                        float)
   (shots-fired                      int16)
   (stage-hit-points                 float)
   (hud                              handle)
   (lowtorso                         handle)
   (legs                             handle)
   (wings                            handle)
   (kid                              handle)
   (explode                          handle)
   (rift-occlude                     handle)
   (last-attack-id                   uint32)
   (current-nav-poly                 nav-poly)
   (shot-anticipate                  sparticle-launch-control)
   (spinners                         handle            4)
   (neck                             joint-mod)
   (previous-flat-travel             vector            :inline)
   (previous-flat-travel-timer       time-frame)
   (previous-flat-travel-long-timer  time-frame)
   (min-state-hit-points             float)
   (countdown-to-roar                int8)
   (for-back-interp                  cam-float-seeker  :inline)
   (run-walk-interp                  cam-float-seeker  :inline)
   (left-right-interp                cam-float-seeker  :inline)
   (walk-turn-interp                 cam-float-seeker  :inline)
   (idle-interp                      cam-float-seeker  :inline)
   (tmp-hit-points                   float)
   (reps-till-idle-alt               int8)
   (last-rotation                    float)
   (no-collision-timer               time-frame)
   (egg-angle                        float             :offset 736)
   (arm-frame                        float)
   (been-to-entity                   symbol)
   (flying-speed                     cam-float-seeker  :inline)
   (wing-sound                       sound-id)
   (wing-sound-playing               symbol)
   (explode-sound                    sound-id)
   (bomb-sound                       sound-id)
   (stop-bomb-sound                  symbol)
   (hit-ring-trans                   vector            :inline)
   (hit-ring-offset                  vector            :inline)
   (ring-cam-pos                     cam-float-seeker  :inline)
   (need-teleport                    symbol)
   )
  (:state-methods
    (beaten symbol)
    explode
    fly-to-ring
    last-gasp
    overload-recover
    fall-down
    tail-attack
    foot-attack
    get-close
    standing-shot
    chase-target
    play-drop-movie
    start-second-stage
    hang-shoot-n-launch
    hidden
    test
    )
  )

  


  (defbehavior grenadier-init-by-other grenadier ((vec vector))
  (init-enemy-collision! self)
  (logior! (-> self mask) (process-mask actor-pause))
  (vector-copy! (-> self root trans) vec)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (init-enemy! self)
  (let ((nav (find-nearest-nav-mesh vec 0.0)) ;; try to find a nav mesh in the vicinity
        ;; verts for the path
        (cverts (new 'static 'inline-array vector 3
                (static-vectorm 1 0 0)
                (static-vectorm 0 1 0)
                (static-vectorm 0 0 1)
                )
          )
        )
    ;; if a nav mesh is close by, use that, otherwise use default
    (if nav
      (change-to nav self)
      (change-to *default-nav-mesh* self)
      )
    ;; allocate path
    (set! (-> self path) (new 'process 'path-control self 'path 0.0 (the entity #f) #f))
    (set! (-> self path curve cverts) cverts)
    (set! (-> self path curve num-cverts) 3)
    )
  (set! (-> self hit-points) (+ (-> self enemy-info default-hit-points) 35.0))
  (go-idle self)
  )

(defbehavior metalkor-init-by-other metalkor ((vec vector))
  (local-vars (sv-16 res-tag))
  (let ((metalkor-pos-quat (new 'static 'quaternion :x 0.0 :y -1.0 :z 0.0))
        )
    ;;manipy code
    ;(quaternion-copy! offset-quat (quaternion-from-two-vectors! metalkor-pos-quat metalkor-pos metalkor-pos-off)) ;make a quat from target-pos 0 and the original vector
    (let ((kor (process-spawn manipy
                            :init
                            manipy-init
                            vec
                            #f
                            (art-group-get-by-name *level* "skel-metalkor" (the (pointer uint32) #f))
                            #f
                            0)
                            ))
    (if kor
      (let ((torso (process-spawn manipy
                                  :init
                                  manipy-init
                                  vec
                                  #f
                                  (art-group-get-by-name *level* "skel-metalkor-lowtorso" (the (pointer uint32) #f))
                                  #f
                                  0
                                  :to
                                  (-> kor 0))
                                  )
            (legs (process-spawn manipy
                                :init
                                manipy-init
                                vec
                                #f
                                (art-group-get-by-name *level* "skel-metalkor-legs" (the (pointer uint32) #f))
                                #f
                                0
                                :to
                                (-> kor 0))
                                ))
                                (send-event (-> kor 0) 'rot-quat metalkor-pos-quat)
                                (send-event (-> torso 0) 'rot-quat metalkor-pos-quat)
                                (send-event (-> legs 0) 'rot-quat metalkor-pos-quat)
                                )))
  )
  (none)
    )

    (defskelgroup skel-rift-ring-ingame rift-ring-in-game rift-ring-in-game-lod0-jg rift-ring-in-game-idle-ja
              ((rift-ring-in-game-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 40)
              )



    (deftype rift-ring-ingame (process-drawable)
  ((anim-speed          delayed-rand-float  :inline)
   (stutter             symbol)
   (spin-sound          sound-id)
   (spin-sound-playing  symbol)
   )
  (:state-methods
    idle
    )
  )


(defstate idle (rift-ring-ingame)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('stutter)
       (set! (-> self stutter) (the-as symbol (-> block param 0)))
       (set-params! (-> self anim-speed) 3 15 0.25)
       (reset! (-> self anim-speed))
       (set! (-> self anim-speed value) -0.25)
       )
      )
    )
  :trans (behavior ()
    (cond
      ((-> self stutter)
       (update! (-> self anim-speed))
       (ja :num! (loop! (+ 0.125 (-> self anim-speed value))))
       )
      (else
        (ja :num! (loop!))
        )
      )
    (sound-play "warp-ring" :id (-> self spin-sound) :position (-> self root trans))
    (set! (-> self spin-sound-playing) #t)
    )
  :code sleep-code
  :post (behavior ()
    (spawn (-> self part) (-> self root trans))
    (ja-post)
    )
  )

(defmethod deactivate ((this rift-ring-ingame))
  (if (-> this spin-sound-playing)
      (sound-stop (-> this spin-sound))
      )
  ((method-of-type process-drawable deactivate) this)
  (none)
  )



  (defun metalkor-appear ()
  (let ((metalkor-pos1 (new 'static 'vector :x (meters -292.9985) :y (meters 353.4276) :z (meters -1640.9791))))
        (process-spawn metalkor metalkor-pos1)
  )
  (none)
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this rift-ring-ingame) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (set! (-> this root) (new 'process 'trsqv))
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-rift-ring-ingame" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> this part) (create-launch-control (-> *part-group-id-table* 1236) this))
  (set! (-> this draw light-index) (the-as uint 10))
  (set! (-> this stutter) #f)
  (set! (-> this spin-sound) (new-sound-id))
  (set! (-> this spin-sound-playing) #f)
  (go (method-of-object this idle))
  (none)
  )

    (defbehavior rift-ring-ingame-init-by-other rift-ring-ingame ((vec vector))
  (set! (-> self root) (new 'process 'trsqv))
  (vector-copy! (-> self root trans) vec)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
    (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-rift-ring-ingame" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (set! (-> self part) (create-launch-control (-> *part-group-id-table* 1236) self))
  (set! (-> self draw light-index) (the-as uint 10))
  (set! (-> self stutter) #f)
  (set! (-> self spin-sound) (new-sound-id))
  (set! (-> self spin-sound-playing) #f)
  (set! (-> self event-hook) (-> (method-of-object self idle) event))
  (go (method-of-object self idle))
  (set! (-> self root scale x) 10.0)
  (set! (-> self root scale y) 10.0)
  (set! (-> self root scale z) 10.0)
  (none)
    )

    (deftype pal-falling-plat (process-drawable)
  ((root  collide-shape-moving :override)
   )
  (:state-methods
    idle
    fall
    )
  )


(defskelgroup skel-pal-falling-plat pal-falling-plat pal-falling-plat-lod0-jg pal-falling-plat-idle-ja
              ((pal-falling-plat-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 5.8)
              )

(defstate idle (pal-falling-plat)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('ridden)
       (go-virtual fall)
       )
      )
    )
  :enter (behavior ()
    (logior! (-> self root root-prim prim-core action) (collide-action rideable))
    )
  :trans rider-trans
  :code (behavior ()
    (ja-no-eval :group! pal-falling-plat-idle-ja :num! zero)
    (transform-post)
    (sleep-code)
    )
  :post rider-post
  )

(defstate fall (pal-falling-plat)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('touch)
       (when ((method-of-type touching-shapes-entry prims-touching?)
              (the-as touching-shapes-entry (-> block param 0))
              (-> self root)
              (the-as uint 8)
              )
         (when (< 18.0 (ja-frame-num 0))
           (let ((v1-6 (-> self skel root-channel 0)))
             (set! (-> v1-6 num-func) num-func-identity)
             (set! (-> v1-6 frame-num) 18.0)
             )
           )
         )
       )
      )
    )
  :enter (behavior ()
    (sound-play "pal-fall-plat")
    )
  :trans rider-trans
  :code (behavior ()
    (ja-no-eval :group! pal-falling-plat-shake-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (logclear! (-> self root root-prim prim-core action) (collide-action rideable))
    (ja-no-eval :group! pal-falling-plat-idle-ja :num! (seek!) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek!))
      )
    (go-virtual idle)
    )
  :post rider-post
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this pal-falling-plat) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 5))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 11059.2 20480.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 12288.0 0.0 1228.8 4096.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid rideable))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) -12288.0 0.0 1228.8 4096.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-19 prim-core action) (collide-action solid rideable))
      (set! (-> v1-19 transform-index) 4)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 8192.0 19660.8)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 8))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-21 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-21 prim-core action) (collide-action))
      (set-vector! (-> v1-21 local-sphere) -16384.0 -4096.0 0.0 16384.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-24 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-24 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-24 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-pal-falling-plat" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object this idle))
  (none)
  )

    (defbehavior pal-falling-plat-init-by-other pal-falling-plat ((vec vector))
  (let ((s4-0 (new 'process 'collide-shape-moving self (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s4-0 reaction) cshape-reaction-default)
    (set! (-> s4-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (let ((s3-0 (new 'process 'collide-shape-prim-group s4-0 (the-as uint 4) 0)))
      (set! (-> s4-0 total-prims) (the-as uint 5))
      (set! (-> s3-0 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> s3-0 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> s3-0 prim-core action) (collide-action solid rideable))
      (set! (-> s3-0 transform-index) 3)
      (set-vector! (-> s3-0 local-sphere) 0.0 0.0 11059.2 20480.0)
      (set! (-> s4-0 root-prim) s3-0)
      )
    (pusher-init s4-0)
    (let ((v1-15 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-15 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-15 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-15 prim-core action) (collide-action solid rideable))
      (set! (-> v1-15 transform-index) 3)
      (set-vector! (-> v1-15 local-sphere) 12288.0 0.0 1228.8 4096.0)
      )
    (let ((v1-17 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 1) (the-as uint 0))))
      (set! (-> v1-17 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-17 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-17 prim-core action) (collide-action solid rideable))
      (set! (-> v1-17 transform-index) 3)
      (set-vector! (-> v1-17 local-sphere) -12288.0 0.0 1228.8 4096.0)
      )
    (let ((v1-19 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 2) (the-as uint 0))))
      (set! (-> v1-19 prim-core collide-as) (collide-spec obstacle pusher))
      (set! (-> v1-19 prim-core collide-with) (collide-spec jak bot player-list))
      (set! (-> v1-19 prim-core action) (collide-action solid rideable))
      (set! (-> v1-19 transform-index) 4)
      (set-vector! (-> v1-19 local-sphere) 0.0 0.0 8192.0 19660.8)
      )
    (let ((v1-21 (new 'process 'collide-shape-prim-sphere s4-0 (the-as uint 8))))
      (set! (-> v1-21 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-21 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-21 prim-core action) (collide-action))
      (set-vector! (-> v1-21 local-sphere) -16384.0 -4096.0 0.0 16384.0)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-24 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-24 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-24 prim-core collide-with))
      )
    (set! (-> self root) s4-0)
    )
    (let ((offset-vec (new-stack-vector0)))
      (vector-copy! (-> self root trans) vec)
      (quaternion-identity! (-> self root quat))
      (vector-identity! (-> self root scale))
    )
  (initialize-skeleton
    self
    (the-as skeleton-group (art-group-get-by-name *level* "skel-pal-falling-plat" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (go (method-of-object self idle))
  (none)
    )




              (defskelgroup skel-onin-highres onin-highres onin-highres-lod0-jg onin-highres-idle-ja
              ((onin-highres-lod0-mg (meters 200)))
              :bounds (static-spherem 0 0 0 5)
              :shadow onin-highres-shadow-mg
              :origin-joint-index 3
              )




  (deftype c-vin-npc (process-taskable)
  ()
  )


(defskelgroup skel-vin vin vin-lod0-jg vin-idle-ja
              ((vin-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 10)
              :shadow vin-shadow-mg
              :origin-joint-index 3
              )


(defmethod init-art! ((this c-vin-npc))
  "@see [[initialize-skeleton]]"
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-vin" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (none)
  )

    (defbehavior c-vin-npc-init-by-other c-vin-npc ((vec vector)) ;spawn vinny
  (process-spawn manipy
                            :init
                            manipy-init
                            vec
                            #f
                            (art-group-get-by-name *level* "skel-vin" (the (pointer uint32) #f))
                            #f
                            0)
  (none)
  )


;;-*-Lisp-*-
(in-package goal)

;; name: dig1-obs.gc
;; name in dgo: dig1-obs
;; dgos: DG1, D3A

;; DECOMP BEGINS




(defpartgroup group-dig-cylinder-hit
  :id 1146
  :duration (seconds 2)
  :flags (use-local-clock)
  :bounds (static-bspherem 0 0 0 6)
  :parts ((sp-item 4960 :flags (bit6) :period (seconds 3) :length (seconds 0.017))
    (sp-item 4961 :flags (bit6) :period (seconds 3) :length (seconds 0.017))
    (sp-item 4962 :period (seconds 3) :length (seconds 0.05))
    (sp-item 4963 :fade-after (meters 60) :period (seconds 3) :length (seconds 0.035) :offset 10)
    (sp-item 4964 :fade-after (meters 60) :falloff-to (meters 60) :period (seconds 3) :length (seconds 0.167) :offset 20)
    (sp-item 4965 :fade-after (meters 200) :falloff-to (meters 200) :period (seconds 3) :length (seconds 0.085) :offset 20)
    (sp-item 4966 :fade-after (meters 150) :falloff-to (meters 150) :period (seconds 3) :length (seconds 0.067) :offset 30)
    )
  )

  (defpart 4966
  :init-specs ((:texture (new 'static 'texture-id :index #x34 :page #xc))
    (:num 0.8)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0) (degrees 360) :store)
    (:scale-y (meters 0.8) (meters 0.2))
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:scalevel-x (meters 0.1) (meters 0.26666668))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -6.2)
    (:fade-b -6.2)
    (:fade-a -0.1254902)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.085))
    (:next-launcher 4967)
    (:conerot-x '*sp-temp*)
    )
  )

(defpart 4965
  :init-specs ((:texture (new 'static 'texture-id :index #x33 :page #xc))
    (:num 0.8)
    (:scale-x (meters 1) (meters 1))
    (:rot-z (degrees 0))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 32.0 32.0)
    (:vel-y (meters 0.02) (meters 0.01))
    (:scalevel-x (meters 0.01) (meters 0.26666668))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -6.2)
    (:fade-b -6.2)
    (:fade-a -0.1254902)
    (:friction 0.95)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.085))
    (:next-launcher 4967)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

(defpart 4967
  :init-specs ((:fade-r -2.1666667)
    (:fade-g -5.0)
    (:fade-b -5.0)
    (:fade-a -0.062068965 -0.72)
    (:next-time (seconds 0.05) (seconds 0.047))
    (:next-launcher 4968)
    )
  )

(defpart 4968
  :init-specs ((:scalevel-x (meters 0.016666668) (meters 0.016666668))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.7)
    (:fade-g -1.7)
    (:fade-b -0.8)
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 4969)
    )
  )

(defpart 4969
  :init-specs ((:scalevel-x (meters 0.0033333334) (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.5833333)
    (:fade-g -0.75)
    (:fade-b -0.9444444)
    (:next-time (seconds 0.5) (seconds 0.097))
    (:next-launcher 4970)
    )
  )

(defpart 4970
  :init-specs ((:fade-r 0.0) (:fade-g 0.0) (:fade-b 0.0) (:fade-a -0.1125))
  )

(defpart 4961
  :init-specs ((:texture (new 'static 'texture-id :index #xca :page #xc))
    (:num 1.0)
    (:scale-x (meters 5))
    (:rot-x (degrees 11.25))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 24.0)
    (:scalevel-x (meters 0.13333334))
    (:rotvel-z (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -2.1333334)
    (:fade-b -4.266667)
    (:fade-a 0.0)
    (:timer (seconds 0.5))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 sp-cpuinfo-flag-14 glow))
    (:next-time (seconds 0.25))
    (:next-launcher 4971)
    )
  )

(defpart 4971
  :init-specs ((:scalevel-x (meters 0))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.85333335)
    (:fade-g -1.7066667)
    (:fade-b -1.7066667)
    (:fade-a -0.64)
    )
  )

(defpart 4960
  :init-specs ((:texture (new 'static 'texture-id :index #xbb :page #xc))
    (:num 1.0)
    (:scale-x (meters 5))
    (:rot-x (degrees 11.25))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 24.0)
    (:scalevel-x (meters 0.5))
    (:rotvel-z (degrees 0.3))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -4.266667)
    (:fade-b -4.266667)
    (:fade-a 0.0)
    (:timer (seconds 0.217))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3 glow))
    (:next-time (seconds 0.1))
    (:next-launcher 4972)
    )
  )

(defpart 4972
  :init-specs ((:scalevel-x (meters -0.2857143))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.8285714)
    (:fade-g -3.6571429)
    (:fade-b -3.6571429)
    (:fade-a -1.3714286)
    )
  )

(defpart 4964
  :init-specs ((:texture (new 'static 'texture-id :index #x32 :page #xc))
    (:num 6.0 2.0)
    (:x (meters 0.25))
    (:scale-x (meters 1) (meters 0.25))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 255.0)
    (:g 255.0)
    (:b 255.0)
    (:a 16.0 48.0)
    (:vel-y (meters 0.083333336) (meters 0.083333336))
    (:scalevel-x (meters 0.006666667) (meters 0.0016666667))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 0.0)
    (:fade-g -3.1)
    (:fade-b -0.1)
    (:accel-y (meters -0.00016666666) (meters -0.00033333333))
    (:friction 0.87)
    (:timer (seconds 3.335))
    (:flags (sp-cpuinfo-flag-2))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 4973)
    (:conerot-x (degrees 0) (degrees 360))
    )
  )

(defpart 4973
  :init-specs ((:scalevel-x (meters 0.0016666667))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.14444445)
    (:fade-g -0.33333334)
    (:fade-b -0.33333334)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 4974)
    )
  )

(defpart 4974
  :init-specs ((:fade-r 0.0) (:fade-g -0.08695652) (:fade-a -0.18478261))
  )

(defpart 4962
  :init-specs ((:texture (new 'static 'texture-id :page #xc))
    (:num 2.0 1.0)
    (:x (meters 0) (meters 0.6))
    (:scale-x (meters 2.5) (meters 2))
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y :copy scale-x)
    (:r 70.0 20.0)
    (:g 70.0 20.0)
    (:b 70.0 20.0)
    (:a 0.0 40.0)
    (:vel-y (meters 0) (meters 0.1))
    (:scalevel-x (meters 0.033333335) (meters 0.02))
    (:rotvel-z (degrees -0.12) (degrees 0.24))
    (:scalevel-y :copy scalevel-x)
    (:fade-r 3.3)
    (:fade-g 1.2)
    (:fade-b 1.2)
    (:fade-a 1.76)
    (:friction 0.88)
    (:timer (seconds 2.367))
    (:flags (sp-cpuinfo-flag-2 sp-cpuinfo-flag-3))
    (:next-time (seconds 0.117) (seconds 0.047))
    (:next-launcher 4975)
    (:conerot-x (degrees -1440) (degrees 2880))
    )
  )

(defpart 4975
  :init-specs ((:scalevel-x (meters 0.0033333334))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -1.0833334)
    (:fade-g -2.1666667)
    (:fade-b -2.1666667)
    (:fade-a -0.46666667)
    (:next-time (seconds 0.15) (seconds 0.047))
    (:next-launcher 4976)
    )
  )

(defpart 4976
  :init-specs ((:fade-r -1.7)
    (:fade-g -0.8)
    (:fade-b -0.8)
    (:fade-a -1.0)
    (:next-time (seconds 0.167))
    (:next-launcher 4977)
    )
  )

(defpart 4977
  :init-specs ((:scalevel-x (meters 0))
    (:scalevel-y :copy scalevel-x)
    (:fade-r -0.17)
    (:fade-g -0.3)
    (:fade-b -0.3)
    (:fade-a -0.1)
    )
  )

(defpart 4963
  :init-specs ((:texture (new 'static 'texture-id :index #x31 :page #xc))
    (:num 4.0 2.0)
    (:scale-x (meters 0.2) (meters 0.5))
    (:rot-x 4)
    (:rot-z (degrees 0) (degrees 360))
    (:scale-y (meters 0.2) (meters 0.1))
    (:r 192.0 64.0)
    (:g 65.0)
    (:b 128.0 64.0)
    (:a 32.0 96.0)
    (:scalevel-x (meters 0.13333334) (meters 0.02))
    (:fade-r -1.4222223)
    (:fade-g -1.4222223)
    (:fade-b -1.4222223)
    (:fade-a -1.4222223)
    (:timer (seconds 0.3))
    (:flags (sp-cpuinfo-flag-2))
    )
  )

(deftype c-dig-bomb-crate-cylinder (rigid-body-object)
  ((flash-counter  int8)
   (attack-id      uint32)
   (wait-time      time-frame)
   )
  (:state-methods
    die
    )
  )


(deftype c-dig-bomb-crate-cylinder-spawn-params (structure)
  ((pos   vector      :inline)
   (vel   vector      :inline)
   (avel  vector      :inline)
   (quat  quaternion  :inline)
   )
  )


(defskelgroup skel-c-dig-bomb-crate-cylinder dig-bomb-crate-cylinder dig-bomb-crate-cylinder-lod0-jg dig-bomb-crate-cylinder-idle-ja
              ((dig-bomb-crate-cylinder-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 0 0 1.5)
              )

(define *c-dig-bomb-crate-cylinder-constants*
  (new 'static 'rigid-body-object-constants
    :info (new 'static 'rigid-body-info
      :mass 1.0
      :inv-mass 1.0
      :linear-damping 0.99
      :angular-damping 0.9
      :bounce-factor 0.5
      :friction-factor 0.1
      :cm-offset-joint (new 'static 'vector :w 1.0)
      :inertial-tensor-box (new 'static 'array meters 3 (meters 1) (meters 3) (meters 1))
      )
    :extra (new 'static 'rigid-body-object-extra-info
      :max-time-step 0.02
      :gravity (meters 80)
      :idle-distance (meters 200)
      :attack-force-scale 2.0
      )
    :name '*c-dig-bomb-crate-cylinder-constants*
    )
  )

(defstate idle (c-dig-bomb-crate-cylinder)
  :virtual #t
  :code (behavior ()
    (go-virtual die)
    )
  )

(defstate active (c-dig-bomb-crate-cylinder)
  :virtual #t
  :enter (behavior ()
    (let ((t9-0 (-> (method-of-type rigid-body-object active) enter)))
      (if t9-0
          (t9-0)
          )
      )
    (set! (-> self flash-counter) 0)
    0
    )
  :trans (behavior ()
    (let ((v1-2 (ja-group)))
      (when (and v1-2 (= v1-2 dig-bomb-crate-cylinder-pulse-ja))
        (let* ((gp-0 (-> self flash-counter))
               (v1-5 gp-0)
               )
          (cond
            ((zero? v1-5)
             (when (>= (ja-aframe-num 0) 1.4)
               (sound-play "dig-bomb-beep" :position (-> self root trans))
               (set-vector! (-> self draw color-mult) 1.1 0.25 0.25 1.0)
               (set! (-> self flash-counter) (+ gp-0 1))
               )
             )
            ((= v1-5 1)
             (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
             (set-vector! (-> self draw color-emissive) 1.0 1.0 1.0 1.0)
             (set! (-> self flash-counter) (+ gp-0 1))
             )
            ((= v1-5 2)
             (set-vector! (-> self draw color-mult) 1.0 1.0 1.0 1.0)
             (set-vector! (-> self draw color-emissive) 0.0 0.0 0.0 1.0)
             (set! (-> self flash-counter) (+ gp-0 1))
             )
            ((= v1-5 3)
             (when (< (ja-aframe-num 0) 1.4)
               (set! (-> self flash-counter) 0)
               0
               )
             )
            )
          )
        )
      )
    )
  :code (behavior ()
    (let ((f30-0 (rand-vu-float-range 0.22 0.27)))
      (set! (-> self wait-time) (+ (current-time) (the int (rand-vu-float-range 0.0 450.0))))
      (while (< (current-time) (-> self wait-time))
        (suspend)
        )
      (ja-no-eval :group! dig-bomb-crate-cylinder-pulse-ja :num! (seek! max f30-0) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      (ja-no-eval :group! dig-bomb-crate-cylinder-idle-ja :num! (seek!) :frame-num 0.0)
      (let ((gp-1 (current-time)))
        (until (time-elapsed? gp-1 (seconds 0.5))
          (suspend)
          )
        )
      (ja-no-eval :group! dig-bomb-crate-cylinder-pulse-ja :num! (seek! max f30-0) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      (ja-no-eval :group! dig-bomb-crate-cylinder-idle-ja :num! (seek!) :frame-num 0.0)
      (let ((gp-2 (current-time)))
        (until (time-elapsed? gp-2 (seconds 0.5))
          (suspend)
          )
        )
      (ja-no-eval :group! dig-bomb-crate-cylinder-pulse-ja :num! (seek! max f30-0) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max f30-0))
        )
      )
    (ja-no-eval :group! dig-bomb-crate-cylinder-idle-ja :num! (seek!) :frame-num 0.0)
    (let ((gp-3 (current-time)))
      (until (time-elapsed? gp-3 (seconds 0.5))
        (suspend)
        )
      )
    (ja-no-eval :group! dig-bomb-crate-cylinder-pulse-ja :num! (seek! max 0.375) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.375))
      )
    (ja-no-eval :group! dig-bomb-crate-cylinder-idle-ja :num! (seek!) :frame-num 0.0)
    (let ((gp-4 (current-time)))
      (until (time-elapsed? gp-4 (seconds 0.25))
        (suspend)
        )
      )
    (ja-no-eval :group! dig-bomb-crate-cylinder-pulse-ja :num! (seek! max 0.4375) :frame-num 0.0)
    (until (ja-done? 0)
      (suspend)
      (ja :num! (seek! max 0.4375))
      )
    (ja-no-eval :group! dig-bomb-crate-cylinder-idle-ja :num! (seek!) :frame-num 0.0)
    (let ((gp-5 (current-time)))
      (until (time-elapsed? gp-5 (seconds 0.125))
        (suspend)
        )
      )
    (dotimes (gp-6 12)
      (ja-no-eval :group! dig-bomb-crate-cylinder-pulse-ja :num! (seek! max 0.437) :frame-num 0.0)
      (until (ja-done? 0)
        (suspend)
        (ja :num! (seek! max 0.437))
        )
      (ja-no-eval :group! dig-bomb-crate-cylinder-idle-ja :num! (seek!) :frame-num 0.0)
      (let ((s5-0 (current-time)))
        (until (time-elapsed? s5-0 (seconds 0.05))
          (suspend)
          )
        )
      )
    (go-virtual die)
    )
  )

(defstate die (c-dig-bomb-crate-cylinder)
  :virtual #t
  :enter (behavior ()
    (send-event (ppointer->process (-> self parent)) 'died)
    (let ((v1-6 (-> self root root-prim)))
      (set! (-> v1-6 prim-core collide-as) (collide-spec))
      (set! (-> v1-6 prim-core collide-with) (collide-spec))
      )
    0
    (logior! (-> self draw status) (draw-control-status no-draw))
    )
  :code (behavior ()
    (sound-play "dig-bomb-explo")
    (let ((gp-1 (new 'stack-no-clear 'explosion-init-params)))
      (set! (-> gp-1 spawn-point quad) (-> self root trans quad))
      (quaternion-copy! (-> gp-1 spawn-quat) (-> self root quat))
      (set! (-> gp-1 radius) 28672.0)
      (set! (-> gp-1 group) (-> *part-group-id-table* 1146))
      (set! (-> gp-1 collide-with)
            (collide-spec backgnd jak crate civilian enemy obstacle vehicle-sphere hit-by-others-list player-list pusher)
            )
      (set! (-> gp-1 penetrate-using) (penetrate explode))
      (explosion-spawn (the-as process-drawable *entity-pool*) explosion gp-1)
      )
    (while (-> self child)
      (suspend)
      )
    (cleanup-for-death self)
    )
  )

(defmethod rigid-body-object-method-46 ((this c-dig-bomb-crate-cylinder) (arg0 process-drawable) (arg1 int) (arg2 symbol) (arg3 event-message-block))
  (case arg2
    (('track)
     #t
     )
    (else
      ((method-of-type rigid-body-object rigid-body-object-method-46) this arg0 arg1 arg2 arg3)
      )
    )
  )

;; WARN: Return type mismatch object vs symbol.
(defmethod rigid-body-object-method-47 ((this c-dig-bomb-crate-cylinder)
                                       (arg0 process-drawable)
                                       (arg1 attack-info)
                                       (arg2 touching-shapes-entry)
                                       (arg3 penetrate)
                                       )
  (the-as
    symbol
    (cond
      ((logtest? (penetrate jak-yellow-shot jak-red-shot jak-blue-shot jak-dark-shot enemy-yellow-shot enemy-dark-shot)
                 arg3
                 )
       (go (method-of-object this die))
       )
      (else
        (if (logtest? (penetrate explode) arg3)
            (set! arg3 (penetrate spin))
            )
        ((method-of-type rigid-body-object rigid-body-object-method-47) this arg0 arg1 arg2 (the-as penetrate arg3))
        )
      )
    )
  )

;; WARN: Return type mismatch sound-id vs none.
(defmethod rigid-body-object-method-45 ((this c-dig-bomb-crate-cylinder) (arg0 rigid-body-impact))
  (let* ((f0-0 (-> arg0 impulse))
         (f1-0 28672.0)
         (f30-0 (* f0-0 (/ 1.0 f1-0) (-> this info info inv-mass)))
         )
    (if (< (* 28672.0 (-> this info info mass)) (-> arg0 impulse))
        (sound-play-by-name
          (static-sound-name "barrel-bomb-hit")
          (new-sound-id)
          (the int (* 1024.0 f30-0))
          0
          0
          (sound-group sfx)
          (-> this root trans)
          )
        )
    )
  (none)
  )

(defmethod rigid-body-object-method-37 ((this c-dig-bomb-crate-cylinder))
  (let ((a1-0 (new 'stack-no-clear 'collide-query)))
    (set! (-> a1-0 start-pos quad) (-> this rbody state position quad))
    (vector-float*! (-> a1-0 move-dist) (-> this rbody state lin-velocity) (seconds-per-frame))
    (let ((v1-3 a1-0))
      (set! (-> v1-3 radius) (+ 4096.0 (-> this root root-prim local-sphere w)))
      (set! (-> v1-3 collide-with) (-> this root root-prim prim-core collide-with))
      (set! (-> v1-3 ignore-process0) this)
      (set! (-> v1-3 ignore-process1) #f)
      (set! (-> v1-3 ignore-pat) (new 'static 'pat-surface :noentity #x1 :nojak #x1 :probe #x1 :noendlessfall #x1))
      (set! (-> v1-3 action-mask) (collide-action solid))
      )
    (fill-using-line-sphere *collide-cache* a1-0)
    )
  (if *display-collide-cache*
      (debug-draw *collide-cache*)
      )
  (rigid-body-object-method-30 this)
  (set! (-> this root transv quad) (-> this rbody state lin-velocity quad))
  (quaternion-copy! (-> this root quat) (-> this rbody state rotation))
  (rigid-body-method-24 (-> this rbody state))
  (let ((v1-19 (-> this rbody))
        (a1-2 (-> this root trans))
        )
    (rigid-body-method-23 (-> v1-19 state) a1-2)
    )
  (set! (-> this node-list data 0 bone transform trans quad) (-> this root trans quad))
  (transform-post)
  0
  (none)
  )

(defmethod allocate-and-init-cshape ((this c-dig-bomb-crate-cylinder))
  (let ((s5-0 (new 'process 'collide-shape-moving this (collide-list-enum usually-hit-by-player))))
    (set! (-> s5-0 dynam) (copy *standard-dynamics* 'process))
    (set! (-> s5-0 reaction) cshape-reaction-default)
    (set! (-> s5-0 no-reaction)
          (the-as (function collide-shape-moving collide-query vector vector object) nothing)
          )
    (set! (-> s5-0 penetrated-by) (penetrate))
    (let ((s4-0 (new 'process 'collide-shape-prim-group s5-0 (the-as uint 2) 0)))
      (set! (-> s5-0 total-prims) (the-as uint 3))
      (set! (-> s4-0 prim-core collide-as) (collide-spec obstacle))
      (set! (-> s4-0 prim-core collide-with)
            (collide-spec backgnd jak crate enemy obstacle hit-by-others-list player-list pusher)
            )
      (set! (-> s4-0 prim-core action) (collide-action solid))
      (set-vector! (-> s4-0 local-sphere) 0.0 0.0 0.0 7168.0)
      (set! (-> s5-0 root-prim) s4-0)
      )
    (let ((v1-12 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-12 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-12 prim-core collide-with)
            (collide-spec backgnd jak crate enemy obstacle hit-by-others-list player-list pusher)
            )
      (set! (-> v1-12 prim-core action) (collide-action solid))
      (set! (-> v1-12 transform-index) 0)
      (set-vector! (-> v1-12 local-sphere) 0.0 2048.0 0.0 4505.6)
      )
    (let ((v1-14 (new 'process 'collide-shape-prim-sphere s5-0 (the-as uint 0))))
      (set! (-> v1-14 prim-core collide-as) (collide-spec obstacle))
      (set! (-> v1-14 prim-core collide-with)
            (collide-spec backgnd jak crate enemy obstacle hit-by-others-list player-list pusher)
            )
      (set! (-> v1-14 prim-core action) (collide-action solid))
      (set! (-> v1-14 transform-index) 0)
      (set-vector! (-> v1-14 local-sphere) 0.0 -2048.0 0.0 4096.0)
      )
    (set! (-> s5-0 nav-radius) (* 0.75 (-> s5-0 root-prim local-sphere w)))
    (let ((v1-17 (-> s5-0 root-prim)))
      (set! (-> s5-0 backup-collide-as) (-> v1-17 prim-core collide-as))
      (set! (-> s5-0 backup-collide-with) (-> v1-17 prim-core collide-with))
      )
    (set! (-> s5-0 max-iteration-count) (the-as uint 2))
    (set! (-> s5-0 event-self) 'touched)
    (set! (-> this root) s5-0)
    )
  0
  (none)
  )

(defmethod init-skel-and-rigid-body ((this c-dig-bomb-crate-cylinder))
  (initialize-skeleton
    this
    (the-as
      skeleton-group
      (art-group-get-by-name *level* "skel-c-dig-bomb-crate-cylinder" (the-as (pointer uint32) #f))
      )
    (the-as pair 0)
    )
  (alloc-and-init-rigid-body-control this *c-dig-bomb-crate-cylinder-constants*)
  (logclear! (-> this mask) (process-mask actor-pause))
  (logior! (-> this rbody state flags) (rigid-body-flag enable-collision))
  (set! (-> this draw light-index) (the-as uint 10))
  0
  (none)
  )







(deftype c-dig-bomb-crate (process-focusable)
  ()
  (:state-methods
    idle
    die
    )
  (:methods
    (dig-bomb-crate-method-29 (_type_ vector) none)
    )
  )

  ;; WARN: Return type mismatch object vs none.
(defbehavior c-dig-bomb-crate-cylinder-init-by-other c-dig-bomb-crate-cylinder ((arg0 c-dig-bomb-crate-cylinder-spawn-params) (arg1 entity-actor))
  (process-entity-set! self arg1)
  (allocate-and-init-cshape self)
  (set! (-> self root trans quad) (-> arg0 pos quad))
  (quaternion-copy! (-> self root quat) (-> arg0 quat))
  (init-skel-and-rigid-body self)
  (logior! (-> self mask) (process-mask platform))
  (vector-float*! (-> self rbody state lin-momentum) (-> arg0 vel) (-> self info info mass))
  (vector-float*! (-> self rbody state ang-momentum) (-> arg0 avel) (-> self info info mass))
  (go-virtual idle)
  (none)
  )



  ;; WARN: Return type mismatch (pointer process) vs (pointer dig-bomb-crate-cylinder).
(defun c-dig-bomb-crate-cylinder-spawn ((arg0 process-tree) (arg1 c-dig-bomb-crate-cylinder-spawn-params) (arg2 entity-actor))
  (process-spawn c-dig-bomb-crate-cylinder arg1 arg2 :to arg0)
  )




(defskelgroup skel-c-dig-bomb-crate dig-bomb-crate dig-bomb-crate-lod0-jg dig-bomb-crate-idle-ja
              ((dig-bomb-crate-lod0-mg (meters 20)) (dig-bomb-crate-lod1-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 4.5)
              )

(defskelgroup skel-c-dig-bomb-crate-explode dig-bomb-crate dig-bomb-crate-explode-lod0-jg dig-bomb-crate-explode-idle-ja
              ((dig-bomb-crate-explode-lod0-mg (meters 999999)))
              :bounds (static-spherem 0 2 0 4.5)
              )

(define *c-dig-bomb-crate-exploder-params*
  (new 'static 'joint-exploder-static-params
    :joints (new 'static 'boxed-array :type joint-exploder-static-joint-params
      (new 'static 'joint-exploder-static-joint-params :joint-index 3 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 4 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 5 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 6 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 7 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 8 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 9 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 10 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 11 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 12 :parent-joint-index -1)
      (new 'static 'joint-exploder-static-joint-params :joint-index 13 :parent-joint-index -1)
      )
    :collide-spec #x1
    :art-level #f
    )
  )

(define *c-dig-bomb-crate-array* (new 'static 'inline-array vector 8
                                 (new 'static 'vector :x -5038.08 :y 5120.0 :z -5038.08)
                                 (new 'static 'vector :x 5038.08 :y 5120.0 :z -5038.08)
                                 (new 'static 'vector :x -5038.08 :y 5120.0 :z 5038.08)
                                 (new 'static 'vector :x 5038.08 :y 5120.0 :z 5038.08)
                                 (new 'static 'vector :x -5038.08 :y 15155.2 :z -5038.08)
                                 (new 'static 'vector :x 5038.08 :y 15155.2 :z -5038.08)
                                 (new 'static 'vector :x -5038.08 :y 15155.2 :z 5038.08)
                                 (new 'static 'vector :x 5038.08 :y 15155.2 :z 5038.08)
                                 )
        )






    (defmethod dig-bomb-crate-method-29 ((this c-dig-bomb-crate) (arg0 vector))
  (let ((s4-0 (-> this root trans)))
    (dotimes (s3-0 8)
      (let ((a0-2 (-> *c-dig-bomb-crate-array* s3-0))
            (s2-0 (new 'stack-no-clear 'c-dig-bomb-crate-cylinder-spawn-params))
            )
        (vector+! (-> s2-0 pos) s4-0 a0-2)
        (vector-! (-> s2-0 vel) (-> s2-0 pos) arg0)
        (vector-normalize! (-> s2-0 vel) (rand-vu-float-range 81920.0 163840.0))
        (+! (-> s2-0 vel y) (rand-vu-float-range 12288.0 32768.0))
        (quaternion-identity! (-> s2-0 quat))
        (set! (-> s2-0 avel x) (rand-vu-float-range -3.0 3.0))
        (set! (-> s2-0 avel y) (rand-vu-float-range -3.0 3.0))
        (set! (-> s2-0 avel z) (rand-vu-float-range -3.0 3.0))
        (c-dig-bomb-crate-cylinder-spawn
          *entity-pool*
          (the-as c-dig-bomb-crate-cylinder-spawn-params (-> s2-0 pos))
          (-> this entity)
          )
        )
      )
    )
  0
  (none)
  )

(defmethod get-trans ((this c-dig-bomb-crate) (arg0 int))
  "@returns the `trans` [[vector]] from the process's `root` (typically either a [[trsqv]] or a [[collide-shape]])"
  (local-vars (v0-0 vector))
  (let ((v1-0 (-> this root)))
    (case arg0
      ((2 3)
       (set! v0-0 (new 'static 'vector))
       (vector+! v0-0 (-> v1-0 trans) (new 'static 'vector :y 12288.0))
       )
      (else
        (set! v0-0 (-> v1-0 trans))
        )
      )
    )
  v0-0
  )



(defstate idle (c-dig-bomb-crate)
  :virtual #t
  :event (behavior ((proc process) (argc int) (message symbol) (block event-message-block))
    (case message
      (('attack)
       (logclear! (-> self mask) (process-mask actor-pause))
       (go-virtual die)
       )
      (('track)
       #t
       )
      )
    )
  :code sleep-code
  )

(defstate die (c-dig-bomb-crate)
  :virtual #t
  :enter (behavior ()
    (send-event (ppointer->process (-> self parent)) 'died)
    (let ((v1-6 (-> self root root-prim)))
      (set! (-> v1-6 prim-core collide-as) (collide-spec))
      (set! (-> v1-6 prim-core collide-with) (collide-spec))
      )
    0
    (logclear! (-> self mask) (process-mask actor-pause))
    (let* ((gp-0 *target*)
           (a0-4 (if (type? gp-0 process-focusable)
                     gp-0
                     )
                 )
           )
      (if a0-4
          (dig-bomb-crate-method-29 self (get-trans a0-4 0))
          )
      )
    )
  :code (behavior ()
    (suspend)
    (logior! (-> self draw status) (draw-control-status no-draw))
    (sound-play "bomb-rack-break")
    (let ((gp-1 (new 'stack 'joint-exploder-tuning (the-as uint 1))))
      (let* ((s5-1 *target*)
             (a0-5 (if (type? s5-1 process-focusable)
                       s5-1
                       )
                   )
             )
        (when a0-5
          (set! (-> gp-1 fountain-rand-transv-lo quad) (-> (get-trans a0-5 0) quad))
          (+! (-> gp-1 fountain-rand-transv-lo y) -16384.0)
          )
        )
      (set! (-> gp-1 fountain-rand-transv-hi x) 24576.0)
      (set! (-> gp-1 fountain-rand-transv-hi y) 81920.0)
      (set! (-> gp-1 fountain-rand-transv-hi z) 12288.0)
      (set! (-> gp-1 fountain-rand-transv-hi w) 32768.0)
      (process-spawn
        joint-exploder
        (art-group-get-by-name *level* "skel-c-dig-bomb-crate-explode" (the-as (pointer uint32) #f))
        6
        gp-1
        *c-dig-bomb-crate-exploder-params*
        :to self
        )
      )
    (suspend)
    (let ((gp-2 (current-time)))
      (until (time-elapsed? gp-2 (seconds 4))
        (suspend)
        )
      )
    (cleanup-for-death self)
    )
  )

;; WARN: Return type mismatch object vs none.
(defmethod init-from-entity! ((this c-dig-bomb-crate) (arg0 entity-actor))
  "Typically the method that does the initial setup on the process, potentially using the [[entity-actor]] provided as part of that.
This commonly includes things such as:
- stack size
- collision information
- loading the skeleton group / bones
- sounds"
  (let ((s4-0 (new 'process 'collide-shape this (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by)
          (penetrate
            generic-attack
            lunge
            flop
            punch
            spin
            roll
            uppercut
            bonk
            tube
            vehicle
            flut-attack
            board
            mech-punch
            dark-punch
            dark-giant
            )
          )
    (let ((v1-3 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-3 prim-core collide-as) (collide-spec enemy camera-blocker))
      (set! (-> v1-3 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-3 prim-core action) (collide-action solid))
      (set! (-> v1-3 transform-index) 3)
      (set-vector! (-> v1-3 local-sphere) 0.0 8192.0 0.0 18432.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-3)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-6 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> this root) s4-0)
    )
  (process-drawable-from-entity! this arg0)
  (initialize-skeleton
    this
    (the-as skeleton-group (art-group-get-by-name *level* "skel-c-dig-bomb-crate" (the-as (pointer uint32) #f)))
    (the-as pair 0)
    )
  (logior! (-> this mask) (process-mask enemy))
  (transform-post)
  (go (method-of-object this idle))
  (none)
  )


  ;; WARN: Return type mismatch object vs none.
(defbehavior c-dig-bomb-crate-init-by-other c-dig-bomb-crate ((vec vector))
  (let ((s4-0 (new 'process 'collide-shape self (collide-list-enum usually-hit-by-player))))
    (set! (-> s4-0 penetrated-by)
          (penetrate
            generic-attack
            lunge
            flop
            punch
            spin
            roll
            uppercut
            bonk
            tube
            vehicle
            flut-attack
            board
            mech-punch
            dark-punch
            dark-giant
            )
          )
    (let ((v1-3 (new 'process 'collide-shape-prim-mesh s4-0 (the-as uint 0) (the-as uint 0))))
      (set! (-> v1-3 prim-core collide-as) (collide-spec enemy camera-blocker))
      (set! (-> v1-3 prim-core collide-with) (collide-spec jak player-list))
      (set! (-> v1-3 prim-core action) (collide-action solid))
      (set! (-> v1-3 transform-index) 3)
      (set-vector! (-> v1-3 local-sphere) 0.0 8192.0 0.0 18432.0)
      (set! (-> s4-0 total-prims) (the-as uint 1))
      (set! (-> s4-0 root-prim) v1-3)
      )
    (set! (-> s4-0 nav-radius) (* 0.75 (-> s4-0 root-prim local-sphere w)))
    (let ((v1-6 (-> s4-0 root-prim)))
      (set! (-> s4-0 backup-collide-as) (-> v1-6 prim-core collide-as))
      (set! (-> s4-0 backup-collide-with) (-> v1-6 prim-core collide-with))
      )
    (set! (-> self root) s4-0)
    )
  (vector-copy! (-> self root trans) vec)
  (quaternion-identity! (-> self root quat))
  (vector-identity! (-> self root scale))
  (initialize-skeleton
  self
  (the-as skeleton-group (art-group-get-by-name *level* "skel-c-dig-bomb-crate" (the-as (pointer uint32) #f)))
  (the-as pair 0)
  )
  (logior! (-> self mask) (process-mask enemy))
  (transform-post)
  (go (method-of-object self die))
  (none)
  )

